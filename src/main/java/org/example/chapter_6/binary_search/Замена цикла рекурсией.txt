private int recFind(long searchKey, int lowerBound, int upperBound) {
    int curIn;
    curIn = (lowerBound + upperBound ) / 2;
    if (a[curIn] == searchKey)
        return curIn; // Элемент найден
    else if (lowerBound > upperBound)
        return nElems; // Элемент не найден
    else if (a[curIn] < searchKey)
            return recFind(searchKey, curIn + 1, upperBound);  // В верхней половине
        else // В нижней половине
            return recFind(searchKey, lowerBound, curIn-1);
}

Пользователь класса (представленный методом main()) при вызове find() может не знать,
сколько элементов содержит массив; в любом случае его не следует обременять поиском начальных значений
upperBound и lowerBound. По этой причине в программе определяется вспомогательный открытый метод find(),
который вызывается методом main() с единственным аргументом — искомым значением ключа.
Метод find() задает правильные исходные значения lowerBound и upperBound (0 и nElems-1), после чего
вызывает приватный рекурсивный метод recFind().
Метод find() выглядит так:

public int find(long searchKey) {
    return recFind(searchKey, 0, nElems-1);
}

В программе BinarySearchRec.java массив содержит 16 элементов.
На рис. 6.9 показано, как метод recFind() этой программы вызывает себя снова и снова для сужающегося диапазона.
Когда «самая внутренняя» версия метода находит искомый элемент с ключом 27, она возвращает его индекс 2
(как видно из вывода упорядоченного массива). Затем это значение последовательно возвращается каждой
версией recFind(); наконец, метод find() передает его пользователю класса.

Рекурсивный двоичный поиск обладает такой же сложностью, как и нерекурсивный: O(logN).
Решение выглядит немного элегантнее, но может работать чуть медленнее.
