Другой недостаток массивов заключается в том, что их размер фиксируется
при создании оператором new.
Обычно при запуске программы вы еще не знаете,
сколько элементов будет размещено в массиве, поэтому размер массива приходится
угадывать.
Завышенная оценка приведет к неэффективному расходованию памяти
под ячейки массива, которые никогда не заполняются. Если оценка окажется заниженной,
то переполнение массива в лучшем случае приведет к сообщению об невозможности вставки,
а в худшем — к аварийному завершению программы.

Другие структуры данных обладают большей гибкостью и могут расширяться
для хранения добавляемых в них элементов. Примером такой структуры является
связанный список.

Следует заметить, что в Java существует класс Vector, который во многих отношениях сходен с массивами,
но поддерживает динамическое расширение. За дополнительные возможности приходится
расплачиваться частичной потерей быстродействия.
При желании вы можете создать собственную реализацию класса вектора. Если
операция пользователя должна привести к переполнению внутреннего массива
этого класса, алгоритм вставки создает новый массив большего размера, копирует
в него содержимое старого массива, а затем вставляет новый элемент. Весь процесс
расширения должен оставаться невидимым для пользователя.
