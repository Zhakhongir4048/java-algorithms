Простейший способ преобразования слова в число заключается в обычном суммировании кодов символов.
Допустим, мы хотим преобразовать слово cats в число.
Сначала символы преобразуются в цифры по правилам нашего доморощенного шифра:
c = 3
a = 1
t = 20
s = 19

Затем полученные цифры суммируются:
3 + 1 + 20 + 19 = 43.

Итак, в нашем словаре слово cats будет храниться в ячейке массива с индексом 43.
Другим словам также назначаются индексы, вычисленные аналогичным образом.

Насколько хорошо работает эта схема? В рамках обсуждения ограничимся словами из 10 букв.
В этом случае первое слово алфавита «a» будет кодироваться следующей последовательностью
(напомним, что пробел кодируется 0):
0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 1 = 1.

Теоретически последним словом в словаре будет последовательность zzzzzzzzzz (10 букв «z»).
Суммируя коды символов, получаем
26 + 26 + 26 + 26 + 26 + 26 + 26 + 26 + 26 + 26 = 260.

Таким образом, все коды в словаре лежат в диапазоне от 1 до 260.
К сожалению, словарь содержит 50 000 слов, и индексов оказывается явно недостаточно.
В каждом элементе массива придется хранить в среднем 192 слова (50 000/260).

Естественно, в рамках схемы «одно слово на один элемент массива» это создаст проблемы.
Теоретически в каждом элементе массива можно разместить подмассив или связанный список слов.
К сожалению, такое решение приведет к серьезному ухудшению скорости доступа.
Обращение к элементу массива будет быстрым, но перебор 192 слов в поисках нужного займет слишком много времени.

Итак, первая попытка преобразования слов в числа оставляет желать лучшего.
Слишком много слов преобразуется в одинаковые индексы. (Например, буквы слов was, tin, give, tend, moan,
tick, bails, dredge и сотни других слов в сумме дают 43, как и буквы слова cats.)
Следовательно, описанный подход не обладает достаточной избирательностью — полученный массив содержит слишком
мало элементов. Диапазон возможных индексов необходимо расширить.
