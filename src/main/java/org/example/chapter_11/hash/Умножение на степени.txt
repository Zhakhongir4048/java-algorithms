А если создать массив, в котором каждое слово (даже каждое потенциальное слово от a до zzzzzzzzzz)
гарантированно занимает отдельную ячейку?
Для этого необходимо разработать такую схему преобразования, в которой каждый символ слова
вносит уникальный вклад в итоговое число.

Вспомните, что в обычном числе, состоящем из нескольких цифр, каждая цифра
представляет значение в 10 раз большее, чем цифра справа от нее. Таким образом, запись 7546 в действительности
означает 7*1000 + 5*100 + 4*10 + 6*1.

Или если перейти к записи со степенями 10: 7*10^3 + 5*10^2 + 4*10^1 + 6*100^0

(Функции ввода в компьютерных программах выполняют аналогичные серии умножений и сложений для преобразования
последовательности цифр, введенной с клавиатуры, в число, хранящееся в памяти.)
В этой схеме число разбивается на цифры, каждая цифра умножается на соответствующую степень 10 (так
как существует 10 возможных цифр), после чего произведения суммируются.
Аналогичным образом можно поступить и со словом: разложить его на буквы, преобразовать буквы в числовые
эквиваленты, умножить их на соответствующие степени 27 (так как существует 27 возможных символов,
включая пробелы) и сложить результаты. В результате для каждого слова генерируется уникальное число.

Допустим, нам потребовалось преобразовать слово cats в число. Мы заменяем
буквы цифрами так, как было показано ранее, после чего умножаем каждое число
на соответствующую степень 27 и суммируем результаты:
3*27^3 + 1*27^2 + 20*27^1 + 19*27^0.
Вычисление степеней дает
3*19 683 + 1*729 + 20*27 + 19*1, а в результате суммирования кодов букв, умноженных на степени, мы получаем
59 049 + 729 + 540 + 19 = 60 337.

Эта схема действительно генерирует уникальное число для каждого потенциального слова.
Мы только что вычислили числовой эквивалент слова из четырех букв.
А что произойдет со словами большего размера? К сожалению, диапазон чисел становится очень большим.

Недостаток этой схемы заключается в том, что элемент массива выделяется для каждой последовательности букв,
независимо от того, существует такое слово в английском языке или нет. Таким образом, в массиве будут зарезервированы
ячейки для «слов» aaaaaaaaaa, aaaaaaaaab, aaaaaaaaac и т. д., вплоть до zzzzzzzzzz.
Лишь небольшая часть ячеек будет задействована для хранения «настоящих» слов,
а большинство ячеек останется пустым.

Первая схема (с суммированием кодов букв) генерировала слишком мало индексов.
Вторая схема (с суммированием кодов букв, умноженных на степени 27) генерирует слишком много индексов.
