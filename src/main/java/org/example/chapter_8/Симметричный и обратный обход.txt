Кроме симметричного обхода, также существует два других алгоритма обхода дерева, называемые прямым и обратным.
Тем не менее эти способы обхода находят применение при разборе или анализе алгебраических выражений.
Двоичное дерево (но не дерево двоичного поиска!) может использоваться для представления
алгебраических выражений с бинарными операторами +, –, / и *.
В корневом узле хранится оператор, а в других узлах — имя переменной (A, B или C) или другой оператор.
Каждое поддерево представляет действительное алгебраическое выражение.

Например, двоичное дерево на рис. 8.11 представляет алгебраическое выражение A*(B+C)
Это пример так называемой инфиксной записи, обычно используемой в алгебре.
При обходе дерева в симметричном порядке генерируется правильная инфиксная запись вида A * B + C,
но круглые скобки вам придется вставить самостоятельно.

Какое отношение все это имеет к прямому и обратному обходу?
В этих алгоритмах обхода используются те же три шага, но выполняются они в другой последовательности.

Для метода прямого обхода preorder() последовательность
выглядит так:
1. Посещение узла.
2. Вызов самого себя для обхода левого поддерева узла.
3. Вызов самого себя для обхода правого поддерева узла.

Для дерева на рис. 8.11 при обходе в прямом порядке будет сгенерировано выражение
*A+BC. Такая запись называется префиксной
Одно из ее преимуществ заключается в том, что в ней никогда не нужны круглые скобки;
выражение полностью однозначно и без них.
От начала выражения каждый оператор применяется к следующим двум операндам.
Для первого оператора * это операнды A и +BC; для второго оператора + — B и C, так что последнее выражение
в инфиксной записи имеет вид B + C. Вставляя его в исходное выражение * A  +  BC (префиксная запись),
мы получаем A * (B + C) в инфиксной записи. Разные порядки обхода дерева помогают преобразовать
алгебраическое выражение из одной формы в другую.
