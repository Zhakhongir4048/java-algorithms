Если преемник входит в число левых потомков правого потомка удаляемого узла,
то удаление выполняется за четыре шага:
1. Сохранить ссылку на правого потомка преемника в поле leftChild родителя преемника.
2. Сохранить ссылку на правого потомка удаляемого узла в поле rightChild преемника.
3. Убрать current из поля rightChild его родителя и сохранить в этом поле ссылку на преемника successor.
4. Убрать ссылку на левого потомка current из объекта current и сохранить ее в поле leftChild объекта successor.

Шаги 1 и 2 выполняются методом getSuccessor(), а шаги 3 и 4 выполняются в delete().
На рис. 8.20 показано изменение ссылок в процессе их выполнения.

А вот как выглядит код реализации этих четырех шагов:
1. successorParent.leftChild = successor.rightChild;
2. successor.rightChild = delNode.rightChild;
3. parent.rightChild = successor;
4. successor.leftChild = current.leftChild;

(На шаге 3 также может использоваться левый потомок parent.)
Числа на рис. 8.20 обозначают связи, изменяемые на каждом из четырех шагов.
Шаг 1 фактически заменяет преемника его правым поддеревом.
Шаг 2 оставляет правого потомка удаляемого узла на положенном месте (это происходит автоматически,
когда преемник является правым потомком удаляемого узла).
Шаги 1 и 2 выполняются в команде if, завершающей метод getSuccessor().
Еще раз приведем соответствующий фрагмент:

    // Если преемник не является правым потомком -> создать связи между узлами
    if (successor != delNode.rightChild) {
        successorParent.leftChild = successor.rightChild;
        successor.rightChild = delNode.rightChild;
    }
    return successor;

Эти действия удобнее выполнять здесь, чем в delete(), потому что в getSuccessor() мы можем легко определить местонахождение родителя преемника в ходе
перемещения по дереву в процессе поиска преемника.
Шаги 3 и 4 мы уже видели; они совпадают с шагами 1 и 2 в случае,
когда преемник является правым потомком удаляемого узла, а соответствующий код находится в команде
if в конце delete().
