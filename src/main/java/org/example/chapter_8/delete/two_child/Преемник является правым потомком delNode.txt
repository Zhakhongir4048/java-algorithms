Если successor является правым потомком current, ситуация немного упрощается,
потому что мы можем просто переместить все поддерево, корнем которого является
преемник, и вставить его на место удаленного узла. Эта операция выполняется
всего за два шага:
1. Отсоединить current от поля rightChild (или leftChild) его родителя. Сохранить
в поле ссылку на преемника.
2. Отсоединить левого потомка current от current и сохранить ссылку на него
в поле leftChild объекта successor.
В коде delete() эти операции выполняются следующими командами:
1. parent.rightChild = successor;
2. successor.leftChild = current.leftChild;
На рис. 8.19 показано, как изменяются ссылки при выполнении этих двух команд.

// Продолжение delete()
else // Два потомка, узел заменяется преемником {

    // Поиск преемника для удаляемого узла (current)
    Node successor = getSuccessor(current);

    // Родитель current связывается с посредником
    if(current == root)
       root = successor;
    else if(isLeftChild)
       parent.leftChild = successor;
    else
       parent.rightChild = successor;

    // Преемник связывается с левым потомком current
    successor.leftChild = current.leftChild;
}
// Конец else для двух потомков
// (преемник не может иметь левого потомка)
return true;
} // Конец метода delete

Шаг 1: если удаляемый узел current является корневым, то он не имеет родителя,
поэтому root просто присваивается successor. В противном случае удаляемый узел может быть либо левым,
либо правым потомком (на рис. 8.19 это правый потомок), поэтому в соответствующем поле
его родителя сохраняется ссылка на successor. Когда delete() возвращает управление,
а current выходит из области видимости, на узел, на который ссылается current, не остается ни одной ссылки,
поэтому он будет уничтожен в ходе уборки мусора Java
Шаг 2: в поле левого потомка преемника сохраняется ссылка на левого потомка current.

Что произойдет, если у преемника имеются свои потомки? Прежде всего, узел преемника заведомо
не имеет левого потомка. Это утверждение истинно в любом случае — и если преемник является
правым потомком удаляемого узла, и если он является одним из левых потомков правого потомка.
Откуда это известно? Вспомните, что алгоритм поиска преемника сначала переходит к правому потомку,
а затем перебирает всех его левых потомков. Перебор прекращается при достижении узла,
не имеющего левого потомка, так что преемник не может иметь левых потомков в соответствии с алгоритмом.
Если бы у него был левый потомок, то последний и стал бы преемником.
С другой стороны, ничто не мешает преемнику иметь правого потомка. Это не создает особых проблем,
когда преемник является правым потомком удаляемого узла. При перемещении преемника его правое
поддерево просто перемещается вместе с ним. С правым потомком удаляемого узла конфликтов тоже нет, потому
что этим правым потомком является сам преемник.
