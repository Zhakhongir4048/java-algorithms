Сначала программа переходит к правому потомку исходного узла, ключ которого должен быть больше ключа узла.
Затем она переходит к левому потомку правого потомка (если он существует),
к левому потомку левого потомка и т. д., следуя вниз по цепочке левых потомков.
Последний левый потомок на этом пути является преемником исходного узла (рис. 8.17).

Фактически мы ищем наименьший узел в наборе узлов, больших исходного узла.
В поддереве правого потомка исходного узла все узлы больше исходного узла,
что следует из самого определения дерева двоичного поиска. В этом дереве ищется наименьшее значение.
Как говорилось выше, минимальный узел поддерева находится отслеживанием пути, состоящего из левых потомков.
Таким образом, алгоритм находит минимальное значение, большее исходного узла, которое и является преемником
удаляемого узла в соответствии с определением.

Если у правого потомка исходного узла нет левых потомков,
то сам правый потомок становится преемником (рис. 8.18).