1) Деревья состоят из узлов, соединенных ребрами.
2) Корневым узлом (или корнем) называется узел верхнего уровня дерева. Корневой узел не имеет родителя.
3) В двоичном дереве узел имеет не более двух потомков.
4) В дереве двоичного поиска ключи всех узлов, являющиеся левыми потомками узла A, меньше ключа A;
ключи всех узлов, являющиеся правыми потомками узла A, больше ключа A (или равны ему).
5) Поиск, вставка и удаление в деревьях выполняются за время O(log N).
6) Узлы соответствуют объектам данных, хранимым в дереве.
7) Ребра обычно представляются в программах ссылками на потомков узла (а иногда и на родителя).
8) Обходом дерева называется посещение всех его узлов в определенном порядке.
9) Простейшие алгоритмы обхода — прямой, симметричный и обратный.
10) Несбалансированным называется дерево, у которого корень имеет больше левых потомков (во всех поколениях),
чем правых (или наоборот).
11) В процессе поиска узла алгоритм сравнивает искомое значение с ключом узла и переходит к левому потомку
этого узла, если искомое значение меньше, или к правому, если оно больше.
12) При выполнении вставки алгоритм сначала находит место для нового узла,
а затем изменяет ссылку на потомка в родительском узле, чтобы она указывала на вставленный узел.
13) При симметричном обходе узлы посещаются в порядке возрастания ключей.
14) Прямой и обратный обход полезны при разборе алгебраических выражений.
15) Если узел не имеет потомков, то для его удаления достаточно записать null
в поле ссылки на потомка в его родительском узле.
16) Чтобы удалить узел с одним потомком, следует записать ссылку на его потомка в поле родительского узла.
17) Чтобы удалить узел с двумя потомками, следует заменить его преемником.
18) Преемник узла A находится поиском наименьшего узла в поддереве, корнем которого является правый потомок A.
19) При удалении узла с двумя потомками возможны разные ситуации в зависимости от того, является ли
преемник правым потомком удаляемого узла или одним из левых потомков (во всех поколениях) правого потомка.
20) Узлы с совпадающими значениями ключей могут создать проблемы в массивах,
потому что при поиске будет найден только первый из них.
21) Деревья могут представляться в памяти компьютера в виде массива,
хотя представление со ссылками является более распространенным.
22) Деревом Хаффмана называется двоичное дерево (но не дерево двоичного поиска!),
использующее алгоритм сжатия данных, называемый кодом Хаффмана.
23) В коде Хаффмана часто встречающиеся символы кодируются наименьшим, а самые редкие символы
— наибольшим количеством битов.
