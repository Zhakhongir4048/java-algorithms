Сначала метод insert() создает новый узел на основе данных, переданных в аргументах.
Далее он должен определить место для вставки нового узла.
Используется примерно такой же код, как при поиске узла.
Различие в том, что при простом поиске обнаружение несуществующего узла (null) означает,
что искомый узел не существует, и приводит к немедленному возвращению управления.
При вставке перед возвращением управления узел включается в дерево (если потребуется,
программа сначала создает его).
Искомым значением является элемент, передаваемый в аргументе id.
Цикл while использует условие true, потому что обнаружение узла с тем же значением, что у id, игнорируется;
узел с совпадающим ключом интерпретируется так, как если бы его ключ был больше искомого.

Место для вставки нового узла всегда находится успешно (если в системе хватит памяти);
когда это произойдет, новый узел включается в дерево, а выполнение цикла while завершается командой return.

Код функции insert():

public void insert(int id, double dd) {
    Node newNode = new Node(); // Создание нового узла
    newNode.iData = id; // Вставка данных
    newNode.dData = dd;
    if (root == null) // Корневой узел не существует
        root = newNode;
    else { // Корневой узел занят
        Node current = root; // Начать с корневого узла
        Node parent;
        while (true) { // (Внутренний выход из цикла)
            parent = current;
            if (id < current.iData) { // Двигаться налево?
                current = current.leftChild;
                if (current == null) { // Если достигнут конец цепочки
                    parent.leftChild = newNode; // вставить слева
                    return;
                }
            } else { // Или направо?
                current = current.rightChild;
                if (current == null) { // Если достигнут конец цепочки,
                    parent.rightChild = newNode; // вставить справа
                    return;
                }
            }
        }
    }
}