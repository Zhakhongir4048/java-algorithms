В таком представлении узлы хранятся в массиве и не связываются ссылками.
Позиция узла в массиве соответствует его положению в дереве. Элемент с индексом 0 представляет корень дерева,
элемент с индексом 1 — его левого потомка и так далее, с перебором слева направо на каждом уровне дерева
(рис. 8.21).
Каждая позиция в дереве (независимо от того, представляет она существующий
узел или нет) соответствует определенной ячейке массива. Включение узла в некоторую позицию дерева
означает вставку узла в соответствующую ячейку массива.
Ячейки, представляющие пустые позиции дерева, заполняются нулями или null.

В такой схеме родитель и потомки узла вычисляются по простым формулам
на основании индекса узла в массиве.
Если индекс узла в массиве равен index, то индекс его левого потомка равен 2*index + 1
Индекс правого потомка: 2*index + 2
Индекс родителя: (index-1) / 2

(оператор / обозначает целочисленное деление без остатка). Рисунок 8.21 поможет вам убедиться
в истинности этих формул.

В большинстве случаев эффективность представления дерева в виде массива оставляет желать лучшего.
Незаполненные и удаленные узлы оставляют пустоты в массиве и, как следствие, приводят
к неэффективному расходованию памяти.
Еще хуже другое: если удаление узла требует перемещения поддеревьев, каждый узел поддерева приходится
перемещать в новую ячейку массива; для больших деревьев эта операция занимает много времени.
Но если удаление запрещено, представление дерева в виде массива может быть весьма полезным,
особенно если динамическое выделение памяти для каждого узла по каким-то причинам занимает слишком
много времени.
