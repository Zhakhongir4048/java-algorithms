Простой пример дает представление о работе симметричного обхода.
Предположим, вам потребовалось обойти дерево, которое состоит всего из трех узлов:
корня (A) с левым (B) и правым (C) потомками.

1) Сначала метод inOrder() вызывается с аргументом A (корневой узел) — назовем эту версию вызова inOrder(A).

2) inOrder(A) сначала вызывает inOrder() для своего левого потомка B (второй вызов inOrder()
будет обозначаться inOrder(B)).

3) Теперь inOrder(B) вызывает inOrder() для своего левого потомка.
Однако левого потомка у узла B нет, поэтому соответствующий аргумент равен null.
Созданный при этом вызов inOrder() назовем inOrder(null).
В итоге, на текущий момент существуют три экземпляра inOrder(): inOrder(A), inOrder(B) и inOrder(null).
Однако как только inOrder(null) обнаруживает, что аргумент равен null, он немедленно возвращает управление.

4) Теперь inOrder(B) переходит к посещению узла B; будем считать, что это означает вывод его данных.
inOrder(B) снова вызывает inOrder() для своего правого потомка. Этот аргумент также равен null, поэтому второй
вызов inorder(null) тоже немедленно возвращает управление. Соответственно вызов inOrder(B)
выполнил шаги 1, 2 и 3, поэтому он возвращает управление (и перестает существовать).

5) Теперь управление возвращается вызову inOrder(A) в точку непосредственно после обхода левого потомка A.

6) Метод посещает A, а затем снова вызывает inOrder() с аргументом C, создавая вызов inOrder(C).

7) Как и inOrder(B), inOrder(C) не имеет дочерних узлов, поэтому шаг 1 возвращает управление без выполнения
каких-либо действий, на шаге 2 посещается узел C, а шаг 3 тоже возвращает управление.
Выполнение inOrder(A) на этом прекращается, вызов возвращает управление, а обход завершается.

Узлы дерева в процессе обхода посещались последовательно, в порядке A, B, C.
В дереве двоичного поиска этот порядок соответствует порядку возрастания ключей.
Более сложные деревья обрабатываются аналогичным образом.
Метод inOrder() вызывает себя для каждого узла до тех пор, пока не переберет все узлы дерева.
