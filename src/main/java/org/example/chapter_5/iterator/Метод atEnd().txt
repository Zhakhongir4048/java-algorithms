С методом atEnd() связана еще одна проблема. Метод может возвращать true, когда итератор указывает на
последний действительный элемент списка или же тогда, когда итератор сместился «за» конец списка
(то есть не указывает ни на какой действительный элемент).
В первом случае усложняется условие цикла, используемого для перебора элементов, потому что вам придется
выполнить операцию с элементом перед проверкой того, является ли он последним (и завершить цикл, если является).
С другой стороны, во втором случае вы узнаете, что итератор находится в конце цикла, когда уже поздно
выполнять какие-либо операции с последним элементом (например, вы не сможете найти последний элемент и
удалить его). Когда atEnd() вернет true, итератор уже не указывает на последний элемент
(и вообще на какой-либо действительный элемент), а в односвязном списке «отступить на шаг назад» уже не удастся.
Мы выбрали первый вариант. В нем итератор всегда указывает на действительную ссылку, хотя, как мы вскоре увидим,
написание цикла с перебором списка потребует осторожности.
