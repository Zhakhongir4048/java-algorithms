package org.example;

/**
 * Побитовые операции в Java
 */
public class BitManipulation {

    public static void main(String[] args) {
        int x = 342;
        System.out.println(Integer.toBinaryString(x));

        /*  ~ — побитовый оператор “НЕ”.
            Он работает очень просто: проходится по каждому биту нашего числа и
            меняет его значение на противоположное: нули — на единицы, единицы — на нули.
            Если мы применим его к нашему числу 342, вот что получится:
            101010110 — число 342 в двоичной системе.
            010101001 — результат выражения ~342
         */
        System.out.println(Integer.toBinaryString(~x));

        /*  & — побитовый оператор “И”
            Он, как видишь, довольно похож по написанию на логический “И” (&&).
            Оператор &&, как ты помнишь, возвращает true только если оба операнда являются истинными.
            Побитовый & работает схожим образом: он сравнивает два числа по битам.
            Результатом этого сравнения является третье число.
            Для примера, возьмем числа 277 и 432:
            100010101 — число 277 в двоичной форме
            110110000 — число 432 в двоичной форме
            Далее оператор & сравнивает первый бит верхнего числа с первым битом нижнего.
            Поскольку это оператор “И”, то результат будет равен 1 только в том случае, если оба бита равны 1.
            Во всех остальных случаях результатом будет 0.

            100010101
            &
            110110000
            _______________
            100010000 — результат работы &

            Мы сравниваем сначала первые биты двух чисел друг с другом, потом вторые биты, третьи и т.д.
            Как видишь, только в двух случаях оба бита в числах были равны 1 (первый и пятый по счету биты).
            Результатом всех остальных сравнений стал 0. Поэтому в итоге у нас получилось число 100010000.
            В десятичной системе ему соответствует число 272
         */
        int x2 = 277;
        int x3 = 432;
        int x4 = x2 & x3; // В десятичной системе 272 получилось в итоге
        System.out.println("x4 = " + x4);
        System.out.println(Integer.toBinaryString(x4));

        /*  | — побитовое “ИЛИ”. Принцип работы тот же — сравниваем два числа по битам.
            Только теперь если хотя бы один из битов равен 1, результат будет равен 1.
            Посмотрим на тех же числах — 277 и 432:
            100010101
            |
            110110000
            _______________
            110110101 — результат работы |
            Здесь уже результат другой: нулями остались только те биты, которые в обоих числах были нулями.
            Результат работы — число 110110101. В десятичной системе ему соответствует число 437.
         */
        int x5 = x2 | x3;
        System.out.println("x5 = " + x5);
        System.out.println(Integer.toBinaryString(x5));

        /*  ^ — побитовое исключающее “ИЛИ” (также известно как XOR)
            Он похож на обычное “или”.
            Разница в одном: обычное “или” возвращает true, если хотя бы один операнд является истинным.
            Но не обязательно один — если оба будут true — то и результат true.
            А вот исключающее “или” возвращает true только если один из операндов является истинным.

            Если истинны оба операнда, обычное “или” вернет true(хотя бы один истинный),
            а вот исключающее или вернет false. Поэтому он и называется исключающим.
            100010101
            ^
            110110000
            _______________
            010100101 — результат работы ^

            Вот и наш результат.
            Те биты, которые были в обоих числах одинаковыми, вернули 0 (не сработала формула “один из”).
            А вот те, которые образовывали пару 0-1 или 1-0, в итоге превратились в единицу.
         */
        int xor = x2 ^ x3;
        System.out.println(xor); // Мы отняли число 432 - 277 = 165 ответ
        System.out.println(Integer.toBinaryString(xor));
    }
}

/*
Бит — минимальная единица измерения информации в компьютере.
Его название происходит от английского “binary digit” — “двоичное число”.
Бит может быть выражен одним из двух чисел: 1 или 0.
Существует специальная система счисления, основанная на единицах и нулях — двоичная.
Любое число в Java можно сконвертировать в его двоичную форму. Для этого нужно использовать классы-обертки.
Мы фактически разделили это число на отдельные биты — нули и единицы.
Именно с ними мы можем выполнять операции, которые называются побитовыми.

Но так как переменная типа int занимает 4 байта, т.е. 32 бита, на самом деле число в переменной хранится как:
00000000 00000000 00000001 01010110 — число 342 в переменной типа int в java
11111111 11111111 11111110 10101001 — результат выражения ~342 в java

Как перевести
Для того, чтобы преобразовать число из десятичной системы счисления в двоичную, необходимо выполнить следующие действия.

Делим десятичное число на 2 и записываем остаток от деления.
Результат деления вновь делим на 2 и опять записываем остаток.
Повторяем операцию до тех пор, пока результат деления не будет равен нулю.
Запишем полученные остатки в обратном порядке и получим искомое число.
Переведем число 37510 в двоичную систему:

375 / 2 = 187 (остаток 1)
187 / 2 = 93 (остаток 1)
93 / 2 = 46 (остаток 1)
46 / 2 = 23 (остаток 0)
23 / 2 = 11 (остаток 1)
11 / 2 = 5 (остаток 1)
5 / 2 = 2 (остаток 1)
2 / 2 = 1 (остаток 0)
1 / 2 = 0 (остаток 1)
Записываем остатки в обратном порядке, получаем результат: 1011101112
*/