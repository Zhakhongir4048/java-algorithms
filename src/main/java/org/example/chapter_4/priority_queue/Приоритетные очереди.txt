Приоритетная очередь является более специализированной структурой данных,
чем стек или очередь, однако и он неожиданно часто оказывается полезным.
У приоритетной очереди, как и у обычной, имеется начало и конец, а элементы извлекаются от начала.
Но у приоритетной очереди элементы упорядочиваются по ключу, так что элемент с наименьшим
(в некоторых реализациях — наибольшим) значением ключа всегда находится в начале.
Новые элементы вставляются в позициях, сохраняющих порядок сортировки.

Давайте применим нашу аналогию с сортировкой почты к приоритетным очередям. Каждый раз,
когда почтальон отдает вам письмо, вы вкладываете его в стопку непрочитанных писем в соответствии с приоритетом.
Если письмо требует немедленного ответа (телефонная компания собирается отключить ваш модем), оно
кладется наверх, а письма, на которые можно ответить в свободное время (письмо от любимой тетушки),
подкладываются под низ стопки. Письма со средним приоритетом размещаются где-то в середине; чем выше приоритет,
тем выше оказывается письмо в стопке. Верх стопки соответствует началу приоритетной очереди
Когда у вас появляется время на чтение, вы берете письмо с верха стопки (из
начала очереди); таким образом, самые важные письма будут обработаны первыми.

Приоритетные очереди, как и стеки с очередями, часто используются программистами как вспомогательные
инструменты. Пример такого рода встретится нам при построении связующего дерева графа в главе 14,
«Взвешенные графы». Кроме того, приоритетные очереди (как и обычные) часто используются в компьютерных системах.
Скажем, в операционной системе с вытесняющей многозадачностью программы могут размещаться в приоритетной
очереди, чтобы высокоприоритетная программа первой получила процессорное время для ее выполнения.
При работе с приоритетными очередями довольно часто требуется получить
доступ к элементу с наименьшим значением ключа (которое может представлять
самый экономичный или быстрый способ выполнения какой-либо операции) — то
есть самым приоритетным является элемент с наименьшим ключом.

Наше обсуждение будет основано именно на таком предположении, хотя во многих ситуациях самым
приоритетным является элемент с наибольшим ключом.

Кроме ускоренного доступа к элементу с наименьшим ключом, приоритетная
очередь также должна обеспечивать относительно быструю вставку.
По этой причине приоритетные очереди, как упоминалось ранее, часто реализуются на основе
структуры данных, называемой кучей (heap), — эта структура рассматривается
в главе 12. А в этой главе будет представлена реализация приоритетной очереди
на базе простого массива. Ее недостатком является медленная вставка; с другой
стороны, она проще, а ее применение более уместно, если количество элементов
невелико или скорость вставки не критична.
